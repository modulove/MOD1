/*
 * Rose Oscillator (Rhodonea) for HAGIWO MOD1
 * Based on RoseLichPatch by antisvin
 * 
 * Rose curves are generated by plotting r = sin(k*theta) in polar coordinates
 * where k is the harmonic ratio (multiplier/divisor)
 * 
 * This creates complex waveforms with multiple "petals" that sound like
 * harmonic-rich oscillators with unique timbres
 * 
 * Hardware: MOD1 module
 * 
 *   WIP:  CV options!
 *
 * - CV1: V/Oct Pitch Control
 * - CV2: FM Input
 * - CV3: Harmonics (morphs sine to rose shape)
 * - CV4: Multiplier (numerator of harmonic ratio)
 * - CV5: Divisor (denominator of harmonic ratio, 0 = free-running)
 * - CV6: Feedback Amount
 * 
 * Outputs:
 * - Left/Real component of complex signal
 * - Right/Imaginary component of complex signal
 */

#include <Arduino.h>

// ========== CONFIGURATION ==========
#define SAMPLE_RATE 48000
#define BASE_FREQ 55.0f      // Base frequency in Hz
#define MAX_RATIO 32         // Maximum harmonic ratio
#define BUFFER_SIZE 32       // Audio buffer size

// Pin definitions - MOD1 Hardware
#define POT1 A0      // Harmonics morphing (rose shape)
#define POT2 A1      // Harmonic ratio (k parameter)
#define POT3 A2      // Coarse frequency/tuning
#define CV1 A3       // V/Oct pitch CV
#define CV2 A0       // FM input / Feedback control
#define LED_PIN 3    // Status LED
#define BUTTON_PIN 4 // Mode selection

// PWM Audio Outputs (high-frequency PWM for audio)
#define PWM_X_PIN 9  // X output (real/left)
#define PWM_Y_PIN 10 // Y output (imaginary/right)

// ========== COMPLEX NUMBER STRUCT ==========
struct ComplexFloat {
    float re;  // Real part
    float im;  // Imaginary part
    
    ComplexFloat() : re(0.0f), im(0.0f) {}
    ComplexFloat(float r, float i) : re(r), im(i) {}
    
    // Set from polar coordinates
    void setPolar(float magnitude, float phase) {
        re = magnitude * cos(phase);
        im = magnitude * sin(phase);
    }
    
    // Get magnitude
    float magnitude() const {
        return sqrt(re * re + im * im);
    }
    
    // Get phase
    float phase() const {
        return atan2(im, re);
    }
    
    // Complex multiplication
    ComplexFloat operator*(const ComplexFloat& other) const {
        return ComplexFloat(
            re * other.re - im * other.im,
            re * other.im + im * other.re
        );
    }
    
    // Complex addition
    ComplexFloat operator+(const ComplexFloat& other) const {
        return ComplexFloat(re + other.re, im + other.im);
    }
    
    // Scalar multiplication
    ComplexFloat operator*(float scalar) const {
        return ComplexFloat(re * scalar, im * scalar);
    }
};

// ========== ROSE OSCILLATOR CLASS ==========
/**
 * A complex (quadrature) oscillator based on Rose (rhodonea curve).
 * This is the CORRECT implementation from antisvin/MyPatches
 * 
 * Key algorithm:
 * t = 1 - harmonics + harmonics * cos(modPhase + last_t * feedback1)
 * x = cos(phase + last_x * feedback2.re) * t
 * y = sin(phase + last_y * feedback2.im) * t
 * 
 * The magic is in the t parameter which modulates the amplitude
 * based on the rose curve modulator phase (k * incr)
 */
class RoseOscillator {
private:
    float mul;          // 2*PI / sampleRate
    float incr;         // frequency * mul (phase increment)
    float phase;        // Main oscillator phase
    float modPhase;     // Modulator phase (creates the rose)
    float k;            // Harmonic ratio (multiplier/divisor)
    float harmonics;    // Morphs between sine (0) and rose (1)
    float feedback1;    // Internal feedback on amplitude modulator
    ComplexFloat feedback2;  // Complex feedback vector
    
    // Last sample values for feedback
    float last_x;
    float last_y;
    float last_t;
    
public:
    RoseOscillator(float baseFreq, float sr) 
        : mul(TWO_PI / sr), phase(0.0f), modPhase(0.0f),
          k(1.0f), harmonics(1.0f), feedback1(0.0f),
          last_x(0.0f), last_y(0.0f), last_t(0.0f) {
        feedback2.re = 0.0f;
        feedback2.im = 0.0f;
        setFrequency(baseFreq);
    }
    
    void setSampleRate(float sr) {
        float freq = getFrequency();
        mul = TWO_PI / sr;
        setFrequency(freq);
    }
    
    void setFrequency(float freq) {
        incr = freq * mul;
    }
    
    float getFrequency() {
        return incr / mul;
    }
    
    void setRatio(float ratio) {
        k = ratio;
    }
    
    void setHarmonics(float h) {
        harmonics = constrain(h, 0.0f, 1.0f);
    }
    
    void setFeedback1(float fb) {
        feedback1 = fb;
    }
    
    void setFeedback2(float magnitude, float phase_rad) {
        feedback2.setPolar(magnitude, phase_rad);
    }
    
    // Generate sample
    ComplexFloat generate(float fmInput = 0.0f) {
        // Calculate rose curve amplitude modulation
        // This is the key: t morphs from constant (sine) to rose-modulated
        float t = 1.0f - harmonics + harmonics * cos(modPhase + last_t * feedback1);
        last_t = t;
        
        // Generate complex oscillator with feedback and amplitude modulation
        float x = cos(phase + last_x * feedback2.re) * t;
        float y = sin(phase + last_y * feedback2.im) * t;
        
        // Store for feedback
        last_x = x;
        last_y = y;
        
        // Update phases
        phase += incr + fmInput;
        modPhase += k * incr;  // Rose curve modulator runs at k * frequency
        
        // Wrap phases to 0-2π
        if (phase >= TWO_PI) {
            phase -= TWO_PI;
        } else if (phase < 0.0f) {
            phase += TWO_PI;
        }
        
        if (modPhase >= TWO_PI) {
            modPhase -= TWO_PI;
        } else if (modPhase < 0.0f) {
            modPhase += TWO_PI;
        }
        
        return ComplexFloat(x, y);
    }
    
    void reset() {
        phase = 0.0f;
        modPhase = 0.0f;
        last_x = 0.0f;
        last_y = 0.0f;
        last_t = 0.0f;
    }
};

// ========== SMOOTHING FILTER ==========
class SmoothValue {
private:
    float value;
    float target;
    float lambda;  // Smoothing factor (0.9-0.99)
    
public:
    SmoothValue(float initialValue = 0.0f, float smoothing = 0.95f) 
        : value(initialValue), target(initialValue), lambda(smoothing) {}
    
    void setTarget(float newTarget) {
        target = newTarget;
    }
    
    float process() {
        value = lambda * value + (1.0f - lambda) * target;
        return value;
    }
    
    float getValue() const {
        return value;
    }
};

// ========== DC BLOCKING FILTER ==========
class DcBlockingFilter {
private:
    float x1, y1;
    const float R = 0.995f;  // Pole location
    
public:
    DcBlockingFilter() : x1(0.0f), y1(0.0f) {}
    
    float process(float input) {
        float output = input - x1 + R * y1;
        x1 = input;
        y1 = output;
        return output;
    }
    
    void reset() {
        x1 = y1 = 0.0f;
    }
};

// ========== V/OCT CONVERTER ==========
class VoltsPerOctave {
private:
    float baseFreq;
    float tuneOffset;
    
public:
    VoltsPerOctave(float base = 440.0f) : baseFreq(base), tuneOffset(0.0f) {}
    
    void setTune(float octaves) {
        tuneOffset = octaves;
    }
    
    float getFrequency(float cvVoltage) {
        float volts = (cvVoltage - 0.5f) * 5.0f;
        return baseFreq * pow(2.0f, volts + tuneOffset);
    }
};

// ========== GLOBAL OBJECTS ==========
RoseOscillator osc(BASE_FREQ, SAMPLE_RATE);
VoltsPerOctave vpo(BASE_FREQ);
DcBlockingFilter dcLeft, dcRight;

// Smooth parameters
SmoothValue smoothHarmonics(0.0f, 0.96f);
SmoothValue smoothRatio(1.0f, 0.9f);
SmoothValue smoothFreq(0.5f, 0.95f);
SmoothValue smoothFeedback(0.0f, 0.96f);

// Audio buffer
ComplexFloat audioBuffer[BUFFER_SIZE];
volatile uint16_t bufferIndex = 0;

// Mode selection
volatile bool buttonPressed = false;
volatile uint8_t currentMode = 0;  // 0=Normal, 1=Feedback mode, 2=Free-running
unsigned long lastButtonPress = 0;

// Button interrupt
void buttonISR() {
    if (millis() - lastButtonPress > 200) {  // Debounce
        buttonPressed = true;
        lastButtonPress = millis();
    }
}

// ========== PWM AUDIO OUTPUT SETUP ==========
// Configure Timer1 for high-frequency PWM on pins 9 and 10
void setupPWMAudio() {
    // Set pins as outputs
    pinMode(PWM_X_PIN, OUTPUT);
    pinMode(PWM_Y_PIN, OUTPUT);
    
    // Configure Timer1 for Fast PWM, 62.5kHz
    // This gives us good audio quality with minimal aliasing
    TCCR1A = _BV(COM1A1) | _BV(COM1B1) | _BV(WGM11);
    TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS10);  // No prescaler
    
    // Set TOP value for 62.5kHz PWM (16MHz / 256 = 62.5kHz)
    ICR1 = 255;
    
    // Start with center values (128 = 0V center)
    OCR1A = 128;  // Pin 9
    OCR1B = 128;  // Pin 10
}

// Write audio sample to PWM outputs
inline void writePWMAudio(float left, float right) {
    // Convert -1.0..+1.0 to 0..255 with 128 center
    int pwmLeft = constrain((int)(left * 127.0f + 128.0f), 0, 255);
    int pwmRight = constrain((int)(right * 127.0f + 128.0f), 0, 255);
    
    OCR1A = pwmLeft;   // Pin 9
    OCR1B = pwmRight;  // Pin 10
}

// ========== UTILITY FUNCTIONS ==========

// Read CV input and convert to 0.0-1.0 range
float readCV(int pin) {
    return analogRead(pin) / 1023.0f;
}

// Convert CV to bipolar -1.0 to +1.0
float readCVBipolar(int pin) {
    return (analogRead(pin) / 1023.0f) * 2.0f - 1.0f;
}

// ========== AUDIO CALLBACK ==========
// This should be called by your timer interrupt at SAMPLE_RATE
void audioCallback() {
    // Handle mode switching
    if (buttonPressed) {
        buttonPressed = false;
        currentMode = (currentMode + 1) % 3;
        
        // Visual feedback on LED
        for (int i = 0; i < currentMode + 1; i++) {
            digitalWrite(LED_PIN, HIGH);
            delay(100);
            digitalWrite(LED_PIN, LOW);
            delay(100);
        }
    }
    
    // Read all inputs
    float pot1 = readCV(POT1);      // Harmonics (rose shape)
    float pot2 = readCV(POT2);      // Ratio control
    float pot3 = readCV(POT3);      // Coarse frequency
    float cv1 = readCV(CV1);        // V/Oct pitch CV
    float cv2 = readCVBipolar(CV2); // FM / Feedback (bipolar)
    
    // Mode-dependent parameter mapping
    float harmonics, ratio, feedback1, feedback2_mag;
    
    switch (currentMode) {
        case 0:  // NORMAL MODE
            // POT1: Harmonics (0-1)
            harmonics = pot1;
            
            // POT2: Simple harmonic ratios (1-8)
            ratio = 1.0f + pot2 * 7.0f;
            
            // CV2: FM input
            feedback1 = 0.0f;
            feedback2_mag = 0.0f;
            break;
            
        case 1:  // FEEDBACK MODE
            // POT1: Harmonics
            harmonics = pot1;
            
            // POT2: Ratio (fractional for complex timbres)
            ratio = 0.5f + pot2 * 8.0f;
            
            // CV2: Amplitude feedback
            feedback1 = cv2 * 0.5f;  // ±0.5
            feedback2_mag = 0.0f;
            break;
            
        case 2:  // COMPLEX MODE
            // POT1: Harmonics
            harmonics = pot1;
            
            // POT2: Ratio
            ratio = 0.5f + pot2 * 8.0f;
            
            // CV2 upper half: feedback1, lower half: feedback2
            if (cv2 > 0) {
                feedback1 = cv2 * 0.8f;
                feedback2_mag = 0.0f;
            } else {
                feedback1 = 0.0f;
                feedback2_mag = -cv2 * 0.6f;
            }
            break;
    }
    
    // Update smooth parameters
    smoothHarmonics.setTarget(harmonics);
    smoothRatio.setTarget(ratio);
    smoothFreq.setTarget(pot3);
    
    // Process smooth values
    float smooth_harmonics = smoothHarmonics.process();
    float smooth_ratio = smoothRatio.process();
    float smooth_freq = smoothFreq.process();
    
    // Calculate frequency from CV1 (V/Oct) and POT3 (coarse)
    // POT3 gives -2 to +2 octaves offset
    float tuneOffset = (smooth_freq - 0.5f) * 4.0f;  // -2 to +2 octaves
    vpo.setTune(tuneOffset);
    float frequency = vpo.getFrequency(cv1);
    
    // Update oscillator parameters
    osc.setFrequency(frequency);
    osc.setRatio(smooth_ratio);
    osc.setHarmonics(smooth_harmonics);
    osc.setFeedback1(feedback1);
    
    // Complex feedback (rotating slowly for interesting effects)
    static float fb2_phase = 0.0f;
    fb2_phase += 0.001f;  // Slow rotation
    if (fb2_phase > TWO_PI) fb2_phase -= TWO_PI;
    osc.setFeedback2(feedback2_mag, fb2_phase);
    
    // Generate complex sample with FM (in normal mode only)
    float fmInput = (currentMode == 0) ? cv2 * 0.5f : 0.0f;
    ComplexFloat sample = osc.generate(fmInput);
    
    // Apply DC blocking
    float left = dcLeft.process(sample.re);
    float right = dcRight.process(sample.im);
    
    // Output to PWM
    writePWMAudio(left, right);
    
    // Store in buffer for monitoring
    audioBuffer[bufferIndex].re = left;
    audioBuffer[bufferIndex].im = right;
    bufferIndex = (bufferIndex + 1) % BUFFER_SIZE;
    
    // LED pulse on strong signal
    static int ledCounter = 0;
    if (++ledCounter > 1000) {
        ledCounter = 0;
        float magnitude = sqrt(left * left + right * right);
        digitalWrite(LED_PIN, magnitude > 0.5f ? HIGH : LOW);
    }
}

// ========== SETUP ==========
void setup() {
    Serial.begin(115200);
    Serial.println("Rose Oscillator for MOD1");
    Serial.println("Based on RoseLichPatch by antisvin");
    Serial.println("");
    
    // Configure input pins
    pinMode(POT1, INPUT);
    pinMode(POT2, INPUT);
    pinMode(POT3, INPUT);
    pinMode(CV1, INPUT);
    pinMode(CV2, INPUT);
    
    // Configure LED and button
    pinMode(LED_PIN, OUTPUT);
    pinMode(BUTTON_PIN, INPUT_PULLUP);
    attachInterrupt(digitalPinToInterrupt(BUTTON_PIN), buttonISR, FALLING);
    
    // LED startup sequence
    for (int i = 0; i < 3; i++) {
        digitalWrite(LED_PIN, HIGH);
        delay(100);
        digitalWrite(LED_PIN, LOW);
        delay(100);
    }
    
    // Initialize PWM audio output
    setupPWMAudio();
    
    // Set default tuning
    vpo.setTune(0.0f);  // Start at base frequency
    
    // Initialize oscillator
    osc.reset();
    
    // Setup Timer2 interrupt for audio callback at SAMPLE_RATE
    // Timer2 is 8-bit, we'll use CTC mode
    cli();  // Disable interrupts
    
    TCCR2A = 0;
    TCCR2B = 0;
    TCNT2 = 0;
    
    // Calculate compare value for desired sample rate
    // For 48kHz: 16MHz / (prescaler * (OCR2A + 1)) = 48000
    // Using prescaler 8: OCR2A = 16000000 / (8 * 48000) - 1 = 40.67 ≈ 41
    OCR2A = 41;  // 48kHz (actually 48.78kHz)
    
    TCCR2A |= (1 << WGM21);  // CTC mode
    TCCR2B |= (1 << CS21);   // Prescaler 8
    TIMSK2 |= (1 << OCIE2A); // Enable compare interrupt
    
    sei();  // Enable interrupts
    
    Serial.println("Initialization complete!");
    Serial.println("Modes:");
    Serial.println("  0: Normal (FM on CV2)");
    Serial.println("  1: Feedback (CV2 controls amplitude feedback)");
    Serial.println("  2: Complex (CV2 controls both feedbacks)");
    Serial.println("");
}

// Timer2 Compare A interrupt - audio callback
ISR(TIMER2_COMPA_vect) {
    audioCallback();
}

// ========== MAIN LOOP ==========
void loop() {
    // Audio processing happens in Timer2 interrupt
    // Use main loop for monitoring and diagnostics
    
    static uint32_t lastDebug = 0;
    if (millis() - lastDebug > 1000) {
        lastDebug = millis();
        
        // Read current values
        float pot1 = readCV(POT1);
        float pot2 = readCV(POT2);
        float pot3 = readCV(POT3);
        float cv1 = readCV(CV1);
        float cv2 = readCVBipolar(CV2);
        
        // Calculate current parameters
        float tuneOffset = (pot3 - 0.5f) * 4.0f;
        float frequency = BASE_FREQ * pow(2.0f, tuneOffset + (cv1 - 0.5f) * 5.0f);
        
        // Debug output
        Serial.print("Mode: ");
        Serial.print(currentMode);
        Serial.print(" | Freq: ");
        Serial.print(frequency, 2);
        Serial.print(" Hz | Harmonics: ");
        Serial.print(pot1, 2);
        Serial.print(" | Ratio: ");
        Serial.print(smoothRatio.getValue(), 2);
        Serial.print(" | CV2: ");
        Serial.print(cv2, 2);
        
        // Calculate and display signal strength
        float avgMagnitude = 0.0f;
        for (int i = 0; i < BUFFER_SIZE; i++) {
            avgMagnitude += sqrt(audioBuffer[i].re * audioBuffer[i].re + 
                               audioBuffer[i].im * audioBuffer[i].im);
        }
        avgMagnitude /= BUFFER_SIZE;
        
        Serial.print(" | Signal: ");
        Serial.println(avgMagnitude, 3);
    }
    
    delay(10);
}
